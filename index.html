<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>$TIME — The Time Coin (Spectacular)</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Barlow+Condensed:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --accent1:#ff00ff;
      --accent2:#00e1ff;
      --bg:#020007;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family: "Barlow Condensed", sans-serif;overflow:hidden;color:#fff}
    #container{position:fixed;inset:0}
    /* UI overlay */
    .ui {
      position: absolute;
      left: 48px;
      top: 48px;
      z-index: 10;
      mix-blend-mode: screen;
    }
    .brand {
      font-family: "Great Vibes", cursive;
      font-size: 64px;
      color: white;
      text-shadow: 0 0 18px var(--accent1), 0 0 40px var(--accent2);
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .tag {
      font-size: 14px;
      color: rgba(255,255,255,0.85);
      text-transform: uppercase;
      letter-spacing: 4px;
    }
    .cta {
      position:absolute;
      right:48px;
      top:48px;
      z-index:10;
    }
    .btn {
      background: linear-gradient(90deg,var(--accent1),var(--accent2));
      padding:14px 22px;border-radius:999px;color:#001; font-weight:700;
      box-shadow:0 10px 40px rgba(0,0,0,0.6),0 0 40px rgba(0,225,255,0.12);
      text-transform:uppercase; cursor:pointer;
    }

    /* center overlay text */
    .centerText {
      position: absolute;
      left:50%;
      top:60%;
      transform: translate(-50%,-50%);
      text-align:center;
      z-index:9;
      pointer-events:none;
    }
    .headline {
      font-size:48px;
      text-transform:uppercase;
      letter-spacing:6px;
      color: #fff;
      -webkit-text-stroke: 1px rgba(0,0,0,0.25);
      text-shadow: 0 0 24px rgba(0,225,255,0.06), 0 0 60px rgba(255,0,255,0.06);
      filter: drop-shadow(0 6px 40px rgba(0,0,0,0.6));
    }
    .sub {
      margin-top:14px;
      color:#cfefff;
      font-size:18px;
      letter-spacing:2px;
      opacity:0.95;
    }

    /* small note */
    .note {
      position: absolute;
      bottom: 18px;
      left: 18px;
      color: rgba(255,255,255,0.6);
      font-size:12px;
      z-index:10;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui">
    <div class="brand">$TIME</div>
    <div class="tag">The only coin you can't print</div>
  </div>

  <div class="cta">
    <button class="btn" onclick="window.scrollTo({top:document.body.scrollHeight,behavior:'smooth'})">Buy $TIME</button>
  </div>

  <div class="centerText">
    <div class="headline">Don’t waste your $TIME</div>
    <div class="sub">The first memecoin backed by the only truly scarce resource.</div>
  </div>

  <div class="note">Tip: Move your mouse — enjoy parallax & depth. (Reduce quality if laggy)</div>

  <!-- Three.js + examples modules (via unpkg CDN) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/GLTFLoader.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { SMAAPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/SMAAPass.js';

    // Scene + renderer
    const container = document.getElementById('container');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2.2, 8);

    // Controls (subtle, will be disabled for interaction)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 4;
    controls.maxDistance = 16;
    controls.enabled = false; // we manage parallax manually

    // POST-PROCESSING (bloom)
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.2);
    bloom.threshold = 0.2;
    bloom.strength = 1.2; // glow intensity
    bloom.radius = 0.6;
    composer.addPass(bloom);

    // optional SMAA for smoothing on desktop
    if (renderer.getPixelRatio() === 1) {
      composer.addPass(new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio()));
    }

    // LIGHTS: big cinematic
    const keyLight = new THREE.DirectionalLight(0xff66ff, 1.2);
    keyLight.position.set(5, 6, 2);
    scene.add(keyLight);

    const fill = new THREE.PointLight(0x00e1ff, 1.0, 20);
    fill.position.set(-6, -2, -4);
    scene.add(fill);

    const rim = new THREE.PointLight(0xffffff, 0.6, 40);
    rim.position.set(0, 6, 10);
    scene.add(rim);

    // SKY / NEBULA: large transparent spheres with additive materials (billboards)
    function addNebula(color, size, x, y, z, speed) {
      const geom = new THREE.PlaneGeometry(size, size);
      const mat = new THREE.MeshBasicMaterial({
        map: generateNebulaTexture(color),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 0.9
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(x, y, z);
      mesh.rotation.z = Math.random() * 0.3;
      mesh.userData = { speed };
      scene.add(mesh);
      return mesh;
    }

    function generateNebulaTexture(tint) {
      const size = 1024;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');

      // radial gradient + noise
      const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/1.2);
      g.addColorStop(0, tint);
      g.addColorStop(0.3, hexToRgba(tint, 0.6));
      g.addColorStop(0.7, hexToRgba('#000000', 0));
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);

      // soft brush strokes
      for(let i=0;i<60;i++){
        ctx.globalAlpha = 0.02 + Math.random()*0.05;
        ctx.fillStyle = hexToRgba(tint, 0.12 + Math.random()*0.12);
        const r = Math.random()*size*0.6;
        const x = size/2 + (Math.random()-0.5)*size*0.4;
        const y = size/2 + (Math.random()-0.5)*size*0.4;
        ctx.beginPath();
        ctx.ellipse(x,y,r,r/2, Math.random()*Math.PI, 0, Math.PI*2);
        ctx.fill();
      }

      // subtle noise
      const imageData = ctx.getImageData(0,0,size,size);
      for(let i=0;i<imageData.data.length;i+=4){
        const v = (Math.random()-0.5)*12;
        imageData.data[i]+=v;
        imageData.data[i+1]+=v;
        imageData.data[i+2]+=v;
      }
      ctx.putImageData(imageData,0,0);

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function hexToRgba(hex, alpha){
      if(hex[0]==='#') hex=hex.slice(1);
      const r=parseInt(hex.slice(0,2),16);
      const g=parseInt(hex.slice(2,4),16);
      const b=parseInt(hex.slice(4,6),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    const neb1 = addNebula('#b400ff', 22, -6, 2, -10, 0.0006);
    const neb2 = addNebula('#00e1ff', 18, 6, -1, -12, 0.0009);
    const neb3 = addNebula('#ff66ff', 14, -2, 3, -8, 0.0004);

    // STARFIELD: points with depth
    const STAR_COUNT = 2000;
    const starGeom = new THREE.BufferGeometry();
    const starPos = new Float32Array(STAR_COUNT*3);
    const starColor = new Float32Array(STAR_COUNT*3);
    for(let i=0;i<STAR_COUNT;i++){
      const r = THREE.MathUtils.randFloatSpread(120);
      const z = THREE.MathUtils.randFloat(-60, -6);
      starPos[i*3+0] = THREE.MathUtils.randFloatSpread(50);
      starPos[i*3+1] = THREE.MathUtils.randFloatSpread(30);
      starPos[i*3+2] = z + Math.random()*10;
      const hue = 180 + Math.random()*120;
      const col = new THREE.Color(`hsl(${hue},90%,80%)`);
      starColor[i*3+0]=col.r; starColor[i*3+1]=col.g; starColor[i*3+2]=col.b;
    }
    starGeom.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    starGeom.setAttribute('color', new THREE.BufferAttribute(starColor,3));
    const starMat = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent:true, opacity:0.95, blending: THREE.AdditiveBlending });
    const stars = new THREE.Points(starGeom, starMat);
    scene.add(stars);

    // CENTRAL HOURGLASS (composed of lathe + glass material)
    function createHourglass(){
      // lathe profile for top/bottom bulbs
      const pts = [];
      for(let i=0;i<12;i++){
        pts.push(new THREE.Vector2(0.5 + Math.sin(i*0.5)*0.05, i*0.08));
      }
      const latheGeo = new THREE.LatheGeometry(pts, 64);
      // glass material (physical)
      const glass = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0,
        roughness: 0,
        transmission: 0.95,
        thickness: 0.6,
        envMapIntensity: 1,
        clearcoat: 1,
        clearcoatRoughness: 0,
        transparent: true,
        opacity: 0.95
      });
      const glassMesh = new THREE.Mesh(latheGeo, glass);
      glassMesh.scale.set(1.5,1.5,1.5);
      glassMesh.rotation.x = Math.PI;
      return glassMesh;
    }

    const hourglass = createHourglass();
    hourglass.position.set(0,0.2,0);
    scene.add(hourglass);

    // SAND: particles inside hourglass using Points
    const PARTICLE_COUNT = 1200;
    const sandGeo = new THREE.BufferGeometry();
    const sandPos = new Float32Array(PARTICLE_COUNT*3);
    for(let i=0;i<PARTICLE_COUNT;i++){
      sandPos[i*3+0] = (Math.random()-0.5)*0.6;
      sandPos[i*3+1] = Math.random()*1.6 - 0.6; // spread along vertical inside bulbs
      sandPos[i*3+2] = (Math.random()-0.5)*0.4;
    }
    sandGeo.setAttribute('position', new THREE.BufferAttribute(sandPos, 3));
    const sandMat = new THREE.PointsMaterial({ size: 0.06, color: 0xffdd66, transparent:true, opacity:0.95, blending:THREE.AdditiveBlending });
    const sand = new THREE.Points(sandGeo, sandMat);
    sand.position.set(0,0.2,0);
    scene.add(sand);

    // subtle geometry: base and frame rings
    const ringMat = new THREE.MeshStandardMaterial({ color:0x111111, metalness:1, roughness:0.25 });
    const base = new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.25,64), ringMat);
    base.position.set(0,-1.1,0);
    scene.add(base);

    // small floating holographic plaques for parallax
    function makePlaque(text, x,y,z, col) {
      const canvas = document.createElement('canvas');
      canvas.width = 512; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = "rgba(0,0,0,0)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font = "bold 48px 'Barlow Condensed'";
      ctx.fillStyle = col;
      ctx.textAlign = "center";
      ctx.fillText(text, canvas.width/2, canvas.height/2+16);
      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false, opacity:0.95, blending:THREE.AdditiveBlending });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(3,0.8,1);
      sp.position.set(x,y,z);
      scene.add(sp);
      return sp;
    }
    const plaque1 = makePlaque("$TIME", -3, 1.8, -6, "#ff66ff");
    const plaque2 = makePlaque("Don't waste it", 3, 1.2, -5, "#00e1ff");

    // Interaction / parallax
    const mouse = new THREE.Vector2(0,0);
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;
    });

    // Resize handling
    window.addEventListener('resize', onWindowResize);
    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Animation / logic
    let t = 0;
    function animate() {
      t += 0.008;

      // move nebula slowly & rotate
      [neb1, neb2, neb3].forEach((n,i)=>{
        n.rotation.z += 0.0008 * (i+1);
        n.position.x += Math.sin(t*(i+1))*0.001;
      });

      // starfield subtle rotation
      stars.rotation.y += 0.00012;

      // hourglass subtle bob & rotate
      hourglass.rotation.y += 0.0015;
      hourglass.position.y = 0.2 + Math.sin(t*0.4)*0.03;

      // sand gravity simulation (simple)
      const pos = sand.geometry.attributes.position.array;
      for(let i=0;i<PARTICLE_COUNT;i++){
        let ix = i*3, iy = i*3+1;
        pos[iy] -= 0.01 + Math.random()*0.01; // fall speed
        // when below lower bound, reset to top (simple loop)
        if(pos[iy] < -0.6) pos[iy] = 1.0 + Math.random()*0.6;
        // slight x wander
        pos[ix] += (Math.random()-0.5)*0.02;
      }
      sand.geometry.attributes.position.needsUpdate = true;

      // parallax camera offset from mouse
      camera.position.x += (mouse.x * 1.2 - camera.position.x) * 0.05;
      camera.position.y += (mouse.y * 0.6 + 1.8 - camera.position.y) * 0.05;
      camera.lookAt(0,0.4,0);

      // animate plaques (billboard subtle)
      plaque1.position.x += Math.sin(t*0.7)*0.002;
      plaque2.position.x -= Math.cos(t*0.6)*0.002;

      // composer render (with bloom)
      composer.render();
      requestAnimationFrame(animate);
    }

    // initial camera tweak
    camera.position.set(0, 1.8, 8);
    animate();

    // Utility: toggle quality if performance issue
    window.toggleLowPerf = function(){
      bloom.strength = 0.4;
      stars.material.size = 0.04;
      sand.material.size = 0.04;
      renderer.setPixelRatio(1);
    }

    // Helper debug: press "L" to lower quality
    window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='l') toggleLowPerf(); });

  </script>
</body>
</html>
